Index: level_manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport random\r\nimport player\r\nimport enemy\r\nimport obstacles\r\n\r\n\r\nclass LevelManager():\r\n    def __init__(self, win, state):\r\n        self.win = win\r\n        self.screen_dim = (win.get_width(), win.get_height())\r\n        self.clock = pygame.time.Clock()\r\n        self.debug = False\r\n        self.state = state\r\n        self.party = {\"Warrior\": player.Warrior((200, self.screen_dim[1] // 2 - 20), None, None, self.win), \"Archer\":\r\n                      player.Archer((200, self.screen_dim[1] // 2 - 20), None, None, self.win), \"Wizard\":\r\n                      player.Wizard((200, self.screen_dim[1] // 2 - 20), None, None, self.win)}\r\n        self.player = self.party[\"Warrior\"]\r\n        self.cur_menu = \"Main\"\r\n        self.respawning = False\r\n\r\n        # Font\r\n        self.title = pygame.font.Font(\"Fonts\\\\Orbitron-Regular.ttf\", 45)\r\n        self.header = pygame.font.Font(\"Fonts\\\\Orbitron-Regular.ttf\", 30)\r\n        self.normal = pygame.font.Font(\"Fonts\\\\Orbitron-Regular.ttf\", 20)\r\n\r\n        # Combat Stuff\r\n        self.combat_encounter = []\r\n        self.current_opponent = None\r\n        self.combat_menu = {\"Main\": {1: \"Attack\", 2: \"Abilities\", 3: \"Swap\"}, \"Swapping\":\r\n                            {1: \"Warrior\", 2: \"Archer\", 3: \"Wizard\"}, \"Abilities\":\r\n                            self.player.abilities}\r\n        self.attack_delay = 0\r\n        self.turn = \"Player\"\r\n        self.turn_count = 1\r\n\r\n        # World Generation and Scrolling data\r\n        self.true_scroll = [0, 0]\r\n        self.CHUNK_SIZE = 16\r\n        self.game_map = {}\r\n        self.grass_img = pygame.image.load('images\\\\cobblestone.jpg')\r\n        self.dirt_img = pygame.image.load('images\\\\rock.png')\r\n        self.plant_img = pygame.image.load('images\\\\plant.png').convert()\r\n        self.plant_img.set_colorkey((255, 255, 255))\r\n        self.tile_index = {1: self.grass_img, 2: self.dirt_img, 3: self.plant_img}\r\n        self.tile_rects = []\r\n        self.cave_img = pygame.image.load('Images\\\\cave.png')\r\n\r\n        # credits for cave img = http://pixeljoint.com/forum/forum_posts.asp?TID=15971&PD=0\r\n        self.cave_scroll_x = 0\r\n        self.score = -56\r\n        self.distance = -56\r\n\r\n        # Title Screen\r\n        self.start_rect = None\r\n        self.start_hover = False\r\n        self.quit_rect = None\r\n        self.quit_hover = False\r\n        self.logo = pygame.image.load(\"Images\\\\logo.png\")\r\n\r\n        # Music by AlexisOrtizSofield from Pixabay\r\n        pygame.mixer.music.load(\"audio\\\\music.mp3\")\r\n        pygame.mixer.music.set_volume(0.5)\r\n        pygame.mixer.music.play(-1)\r\n\r\n        # Obstacle Spawn Data\r\n        self.onscreen_enemies = []\r\n        self.onscreen_hazards = []\r\n        self.spawn_range = (1.7, 3.2)\r\n        self.object_spawn_timer = random.uniform(self.spawn_range[0], self.spawn_range[1])\r\n\r\n        # spawning of attacks\r\n        warrior_attack_img = pygame.image.load(\"images\\\\sword.png\")\r\n        self.warrior_attack_img_resize = pygame.transform.scale(warrior_attack_img, (100,100))\r\n        bolt_img = pygame.image.load(\"images\\\\lightning.png\")\r\n        self.bolt_img_icon = pygame.transform.scale(bolt_img, (36, 36))\r\n        blaze_img = pygame.image.load(\"images\\\\blaze.png\")\r\n        self.blaze_img_icon = pygame.transform.scale(blaze_img, (36, 36))\r\n        self.cur_effect_img = None\r\n        self.effect_speed = 10\r\n        self.effect_origin = 225\r\n\r\n        # Level Data\r\n        self.level_dist = 1000\r\n        self.level_timer = 60\r\n        self.cur_level = 1\r\n        self.available_enemies = [enemy.BasicEnemy,enemy.SecondEnemy]\r\n        self.available_hazards = [obstacles.Barricade]\r\n        self.level_boss = enemy.BasicBoss\r\n        self.boss_defeated = False\r\n        self.boss_encounter = False\r\n        self.levels = {1: [self.player.speed, self.spawn_range, self.available_enemies, self.available_hazards, self.level_boss, self.level_dist, self.level_timer],\r\n                       2: [150, (1.3, 2.5), [enemy.BasicEnemy], [obstacles.Barricade], enemy.BasicBoss, 500, 110],\r\n                       3: [175, (1.5, 3), [enemy.BasicEnemy], [obstacles.Barricade], enemy.BasicBoss, 1000, 90]}\r\n\r\n        self.chunk_timer = 2\r\n        self.pit = False\r\n\r\n    def level_changer(self):\r\n        \"\"\"\r\n        Changes all difficulty parameters to the corresponding values in the levels dictionary\r\n        \"\"\"\r\n        if self.distance >= self.levels[self.cur_level][5] and self.boss_defeated and self.cur_level + 1 in self.levels:\r\n            self.cur_level += 1\r\n            self.spawn_range = self.levels[self.cur_level][1]\r\n            self.available_enemies = self.levels[self.cur_level][2]\r\n            self.available_hazards = self.levels[self.cur_level][2]\r\n            self.level_boss = self.levels[self.cur_level][4]\r\n            self.level_dist = self.levels[self.cur_level][5]\r\n            self.level_timer = self.levels[self.cur_level][6]\r\n            self.object_spawn_timer = random.uniform(self.spawn_range[0], self.spawn_range[1])\r\n            self.boss_defeated = False\r\n            for character in self.party:\r\n                self.party[character].speed = self.levels[self.cur_level][0]\r\n                self.party[character].health = self.party[character].max_health\r\n        else:\r\n            self.object_spawn_timer = random.uniform(self.spawn_range[0], self.spawn_range[1])\r\n            self.boss_defeated = False\r\n\r\n    def generate_chunk(self, x, y):\r\n        cal = self.screen_dim[1] / 2 / self.CHUNK_SIZE\r\n        chunk_data = []\r\n        for y_pos in range(self.CHUNK_SIZE):\r\n            for x_pos in range(self.CHUNK_SIZE):\r\n                target_x = x * self.CHUNK_SIZE + x_pos\r\n                target_y = y * self.CHUNK_SIZE + y_pos\r\n                tile_type = 0 # nothing\r\n                if self.pit == False:\r\n                    if target_y > cal:\r\n                        tile_type = 2  # dirt\r\n                    elif target_y == cal:\r\n                        tile_type = 1  # grass\r\n                if self.pit:\r\n                    if target_y > cal:\r\n                        tile_type = 0  # dirt\r\n                    elif target_y == cal:\r\n                        tile_type = 0  # grass\r\n                if tile_type != 0:\r\n                    chunk_data.append([[target_x,target_y],tile_type])\r\n        return chunk_data\r\n\r\n    def respawn(self, dt):\r\n        self.player.y = self.screen_dim[1] // 2 - 20\r\n        self.player.speed = 100\r\n        for tile in self.tile_rects:\r\n            if tile.x > self.player.x:\r\n                self.true_scroll[0] += self.player.speed * dt\r\n                self.player.update(self.state, self.tile_rects, dt, self.onscreen_enemies, self.onscreen_hazards)\r\n                for e in self.onscreen_enemies:\r\n                    e.update(dt, self.player.rect, self.state)\r\n                for h in self.onscreen_hazards:\r\n                    h.update(dt, self.player.rect)\r\n                if self.player.can_jump:\r\n                    self.respawning = False\r\n                    break\r\n\r\n    def update(self):\r\n        \"\"\"\r\n        General updates called every frame\r\n        \"\"\"\r\n        global mid_attack, special_attack\r\n        delta_time = self.clock.tick() / 1000\r\n        self.level_timer -= delta_time\r\n        if not self.respawning:\r\n            if self.chunk_timer >= 0:\r\n                self.chunk_timer -= delta_time\r\n            if self.chunk_timer <= 0:\r\n                self.pit = not self.pit\r\n                if self.pit:\r\n                    self.chunk_timer = random.uniform(0.1, 0.3)\r\n                else:\r\n                    self.chunk_timer = random.uniform(1.5, 2)\r\n\r\n        # Title Screen Updates\r\n        if self.state == \"Title\" or self.state == \"Resume\":\r\n            mouse_pos = pygame.mouse.get_pos()\r\n            if self.start_rect:\r\n                if self.start_rect[0] - 5 < mouse_pos[0] < self.start_rect[0] + self.start_rect[2] + 5 and \\\r\n                        self.start_rect[1] - 5 < mouse_pos[1] < self.start_rect[1] + self.start_rect[3] + 5:\r\n                    self.start_hover = True\r\n                else:\r\n                    self.start_hover = False\r\n            if self.quit_rect:\r\n                if self.quit_rect[0] - 5 < mouse_pos[0] < self.quit_rect[0] + self.quit_rect[2] + 5 and \\\r\n                        self.quit_rect[1] - 5 < mouse_pos[1] < self.quit_rect[1] + self.quit_rect[3] + 5:\r\n                    self.quit_hover = True\r\n                else:\r\n                    self.quit_hover = False\r\n\r\n        if self.state == \"Runner\":\r\n            if not self.respawning:\r\n                if self.party[\"Archer\"].runner_moves[\"Dash\"][0] <= 0:\r\n                    self.player.speed = self.levels[self.cur_level][0]\r\n                self.true_scroll[0] += self.player.speed * delta_time\r\n                self.cave_scroll_x -= 50 * delta_time\r\n                self.runner_cooldowns(delta_time)\r\n                self.player.update(self.state, self.tile_rects, delta_time, self.onscreen_enemies, self.onscreen_hazards)\r\n            if self.player.y > self.screen_dim[1] // 2 + 150:\r\n                self.respawning = True\r\n                for character in self.party:\r\n                    self.party[character].health -= int(self.party[character].max_health * 0.1)\r\n            if self.respawning:\r\n                self.respawn(delta_time)\r\n            # Updates for abilities that extend beyond just the player\r\n            self.arrow = self.party[\"Archer\"].arrow\r\n            if self.party[\"Archer\"].arrow is not None:\r\n                result = self.party[\"Archer\"].arrow.update(delta_time, self.onscreen_enemies)\r\n                if result:\r\n                    self.arrow = None\r\n                    self.party[\"Archer\"].arrow = None\r\n            if self.party[\"Wizard\"].runner_moves[\"Shield\"][0] > 0:\r\n                opacity = 50 * self.party[\"Wizard\"].runner_moves[\"Shield\"][0]\r\n                self.party[\"Wizard\"].shield_surf.set_alpha(int(opacity))\r\n            if self.party[\"Archer\"].runner_moves[\"Dash\"][0] > 0:\r\n                self.player.speed += 100\r\n            for e in self.onscreen_enemies:\r\n                if e.x <= self.distance:\r\n                    self.score += e.clear_points\r\n                    e.clear_points = 0\r\n                e.y = 400 - e.height\r\n                e.speed = self.player.speed     # Make sure to match if dash is on\r\n            for h in self.onscreen_hazards:\r\n                if h.x <= self.distance:\r\n                    self.score += h.clear_points\r\n                    h.clear_points = 0\r\n                h.y = 400 - h.height\r\n                h.speed = self.player.speed\r\n            # Sync the current jump power for the whole party\r\n            self.sync_party()\r\n            # Spawn timer\r\n            self.object_spawn_timer -= delta_time\r\n            # Enemy Collision and Combat Generation\r\n            for e in self.onscreen_enemies:\r\n                if e.weapon_collision and e.__class__ != enemy.BasicBoss:\r\n                    self.onscreen_enemies.remove(e)\r\n                    self.score += 150\r\n                    break\r\n                if not self.respawning:\r\n                    hit = e.update(delta_time, self.player.rect, \"Runner\")\r\n                    if hit and self.party[\"Wizard\"].runner_moves[\"Shield\"][0] <= 0 or hit and e.__class__ == enemy.BasicBoss:\r\n                        if e.__class__ == enemy.BasicBoss:\r\n                            self.boss_encounter = True\r\n                        self.combat_encounter = [e]\r\n                        for i in range(random.randint(1, 2)):\r\n                            next_enemy = random.randint(0, len(self.available_enemies) - 1)\r\n                            new_enemy = self.available_enemies[next_enemy]((self.screen_dim[0] // 2, self.screen_dim[1] // 2 - 20), self.state, self.player.speed)\r\n                            self.combat_encounter.append(new_enemy)\r\n                        self.onscreen_enemies.remove(e)\r\n                        for ec in self.combat_encounter:\r\n                            ec.x = 600\r\n                            ec.y = 400 - e.height // 2\r\n                        for character in self.party:\r\n                            self.party[character].y = 380\r\n                        self.attack_delay = 0\r\n                        mid_attack = False\r\n                        self.state = \"Combat\"\r\n                # Despawn offscreen enemies\r\n                if e.x + e.radius <= 0:\r\n                    self.onscreen_enemies.remove(e)\r\n            for h in self.onscreen_hazards:\r\n                if h.__class__ == obstacles.Barricade and  h.weapon_collision:\r\n                    self.onscreen_hazards.remove(h)\r\n                    self.score += h.clear_points + 50\r\n                    break\r\n                if not self.respawning:\r\n                    hit = h.update(delta_time, self.player.rect)\r\n                    if hit and self.party[\"Wizard\"].runner_moves[\"Shield\"][0] <= 0:\r\n                        for character in self.party:\r\n                            self.party[character].health -= int(self.party[character].max_health * 0.1)\r\n                        self.respawn(delta_time)\r\n                if h.x <= 0:\r\n                    self.onscreen_hazards.remove(h)\r\n\r\n        if self.state == \"Combat\":\r\n            for character in self.party:\r\n                self.party[character].update(self.state, self.tile_rects, delta_time, self.onscreen_enemies, self.onscreen_hazards)\r\n            self.attack_delay -= delta_time\r\n            self.current_opponent = self.combat_encounter[0]\r\n            if self.turn == \"Player\":\r\n                if self.attack_delay > 0:\r\n                    self.effect_origin += delta_time + self.effect_speed\r\n                if self.cur_menu == \"Main\":\r\n                    if self.player.selection_made:\r\n                        if self.player.selection == 1:\r\n                            if self.attack_delay <= 0 and not mid_attack:\r\n                                self.attack_delay = 0.25\r\n                                self.effect_origin = 215\r\n                                if self.player.__class__ == player.Warrior:\r\n                                    self.cur_effect_img = self.warrior_attack_img_resize\r\n                                elif self.player.__class__ == player.Archer:\r\n                                    self.cur_effect_img = self.warrior_attack_img_resize    # Swap with arrow image\r\n                                else:\r\n                                    self.cur_effect_img = self.warrior_attack_img_resize    # Swap with something else?\r\n                                mid_attack = True\r\n                            elif self.attack_delay <= 0 and mid_attack:\r\n                                self.attack(self.player, self.current_opponent)\r\n                                self.change_turn()\r\n                                mid_attack = False\r\n                        elif self.player.selection == 2:\r\n                            self.menu_change(\"Abilities\")\r\n                        elif self.player.selection == 3:\r\n                            self.menu_change(\"Swapping\")\r\n                elif self.cur_menu == \"Abilities\":\r\n                    if self.player.selection_made:\r\n                        if self.player.selection == 0:\r\n                            self.menu_change(\"Main\")\r\n                        else:\r\n                            if self.player.ability_cooldowns[self.player.selection - 1] == 0:\r\n                                special_attack = self.player.do_ability(self.current_opponent, self.party)\r\n                                if special_attack:\r\n                                    # Begin animation\r\n                                    if self.attack_delay <= 0 and not mid_attack:\r\n                                        self.attack_delay = 0.25\r\n                                        self.effect_origin = 215\r\n                                        self.cur_effect_img = special_attack.image\r\n                                        mid_attack = True\r\n                                    # Animation end\r\n                                    elif self.attack_delay <= 0 and mid_attack:\r\n                                        self.attack(special_attack, self.current_opponent)\r\n                                        self.player.ability_cooldowns[self.player.selection - 1] = self.player.ability_cooldowns[self.player.selection + 1]\r\n                                        self.change_turn()\r\n                                        mid_attack = False\r\n                                else:\r\n                                    # If the ability wasn't an attack\r\n                                    self.player.ability_cooldowns[self.player.selection - 1] = self.player.ability_cooldowns[self.player.selection + 1]\r\n                                    self.change_turn()\r\n                            else:\r\n                                self.menu_change(\"Main\")\r\n                elif self.cur_menu == \"Swapping\":\r\n                    if self.player.selection_made:\r\n                        if self.player.selection == 0:\r\n                            self.menu_change(\"Main\")\r\n                        elif self.player.selection == 1:\r\n                            self.player = self.party[\"Warrior\"]\r\n                            self.change_turn()\r\n                            if self.current_opponent.stunned[0] == \"True\":\r\n                                self.attack_delay = 0\r\n                        elif self.player.selection == 2:\r\n                            self.player = self.party[\"Archer\"]\r\n                            self.change_turn()\r\n                            if self.current_opponent.stunned[0] == \"True\":\r\n                                self.attack_delay = 0\r\n                        elif self.player.selection == 3:\r\n                            self.player = self.party[\"Wizard\"]\r\n                            self.change_turn()\r\n                            if self.current_opponent.stunned[0] == \"True\":\r\n                                self.attack_delay = 0\r\n            self.current_opponent.update(delta_time, self.player.rect, \"Combat\")\r\n            if self.turn == \"Enemy\":\r\n                if self.current_opponent.health <= 0:\r\n                    self.score += 50\r\n                    self.combat_encounter.remove(self.current_opponent)\r\n                    self.change_turn()\r\n                    self.attack_delay = 0\r\n                else:\r\n                    if self.current_opponent.stunned[0] == \"True\":\r\n                        self.change_turn()\r\n                        self.attack_delay = 0\r\n                    else:\r\n                        if self.attack_delay > 0:\r\n                            self.effect_origin -= delta_time + self.effect_speed\r\n                        elif self.attack_delay <= 0:\r\n                            self.attack(self.current_opponent, self.player)\r\n                            self.change_turn()\r\n            if not self.combat_encounter:\r\n                if self.boss_encounter:\r\n                    self.boss_defeated = True\r\n                    self.boss_encounter = False\r\n                    self.level_changer()\r\n                self.state = \"Runner\"\r\n                self.player.x = 200\r\n                self.player.y = self.screen_dim[1] // 2 - 20\r\n\r\n    def attack(self, attackee, attacked):\r\n        damage = attackee.attack - random.randint(int(attacked.defense - 15), int(attacked.defense))\r\n        if damage < 0:\r\n            damage = 0\r\n        crit_chance = attackee.luck * 100\r\n        dodge_chance = attacked.dodge * 100\r\n        if random.randint(1, 100) <= crit_chance:\r\n            damage *= 2\r\n        elif random.randint(1, 100) <= dodge_chance:\r\n            damage = 0\r\n        attacked.health -= damage\r\n        if attackee.special_effect:\r\n            debuff_chance = attackee.effect_chance * 100\r\n            if random.randint(1, 100) <= debuff_chance:\r\n                attacked.debuffs.append(attackee.special_effect)\r\n\r\n    def menu_change(self, next_menu):\r\n        self.player.selection_made = False\r\n        if self.cur_menu == \"Swapping\":\r\n            self.player.selection = 3\r\n        elif self.cur_menu == \"Abilities\":\r\n            self.player.selection = 2\r\n        else:\r\n            self.player.selection = None\r\n        self.cur_menu = next_menu\r\n\r\n    def sync_party(self):\r\n        for character in self.party:\r\n            self.party[character].x = self.player.x\r\n            self.party[character].y = self.player.y\r\n            self.party[character].jump_power = self.player.jump_power\r\n\r\n    def runner_cooldowns(self, dt):\r\n        for character in self.party:\r\n            for ability in self.party[character].runner_moves:\r\n                if self.party[character].runner_moves[ability][0] > 0:\r\n                    self.party[character].runner_moves[ability][0] -= dt\r\n                    if self.party[character].runner_moves[ability][0] <= 0:\r\n                        self.party[character].runner_moves[ability][1] = self.party[character].runner_moves[ability][2]\r\n                elif self.party[character].runner_moves[ability][1] > 0:\r\n                    self.party[character].runner_moves[ability][1] -= dt\r\n\r\n    def change_turn(self):\r\n        \"\"\"\r\n        Change the turn status between Player and Enemy, initializing all variables that need to be set once\r\n        before a turn is taken, adding to the encounter's turn count and decreasing all cooldowns or\r\n        buff / debuff turn timers that are enabled\r\n        \"\"\"\r\n        if self.turn == \"Player\":\r\n            self.turn = \"Enemy\"\r\n            self.attack_delay = 0.25\r\n            self.effect_origin = 450\r\n            self.cur_effect_img = self.warrior_attack_img_resize\r\n            if self.current_opponent.stunned[0] == \"True\":  # Stun turn timer\r\n                self.current_opponent.stunned[1] -= 1\r\n            if self.current_opponent.burned[0] == \"True\":  # Burn turn timer\r\n                self.current_opponent.health -= 15\r\n                self.current_opponent.burned[1] -= 1\r\n            if self.current_opponent.pierced[0] == \"True\":  # Pierce turn timer\r\n                self.current_opponent.pierced[1] -= 1\r\n        else:\r\n            for character in self.party:\r\n                if self.party[character].ability_cooldowns[0] > 0:  # Cooldown for ability 1\r\n                    self.party[character].ability_cooldowns[0] -= 1\r\n                if self.party[character].ability_cooldowns[1] > 0:  # Cooldown for ability 2\r\n                    self.party[character].ability_cooldowns[1] -= 1\r\n                if self.party[character].fortify[0] == \"True\":   # Fortify turn timer\r\n                    self.party[character].fortify[1] -= 1\r\n                if self.party[character].cover[0] == \"True\":\r\n                    self.party[character].cover[1] -= 1\r\n            self.turn = \"Player\"\r\n        self.menu_change(\"Main\")\r\n        self.turn_count += 1\r\n\r\n    def handle_input(self):\r\n        \"\"\"\r\n        Handles input between the player and UI / game objects\r\n        :return: True if the player is exiting the game\r\n        \"\"\"\r\n        event = pygame.event.poll()\r\n\r\n        if self.state == \"Runner\":\r\n            self.player = self.party[self.player.handle_running_input(event)]\r\n        elif self.state == \"Combat\":\r\n            self.player.handle_combat_input(event, self.cur_menu)\r\n        if event.type == pygame.QUIT:\r\n            return True\r\n        if event.type == pygame.KEYDOWN:\r\n            if event.key == pygame.K_ESCAPE:\r\n                if self.state == \"Title\" or self.state == \"Resume\":\r\n                    return True\r\n                else:\r\n                    self.state = \"Resume\"\r\n            elif event.key == pygame.K_F1:\r\n                if self.debug:\r\n                    self.debug = False\r\n                else:\r\n                    self.debug = True\r\n        if event.type == pygame.MOUSEBUTTONDOWN:\r\n            if self.state == \"Title\" or self.state == \"Resume\":\r\n                if event.button == 1 and self.start_hover:\r\n                    self.state = \"Runner\"\r\n                if event.button == 1 and self.quit_hover:\r\n                    return True\r\n\r\n    def draw(self):\r\n        # Background\r\n        self.win.blit(self.cave_img, (self.cave_scroll_x, 0))\r\n        self.win.blit(self.cave_img, (self.cave_scroll_x + self.cave_img.get_width(), 0))\r\n        if self.cave_scroll_x <= -self.cave_img.get_width():\r\n            self.cave_scroll_x = 0\r\n        # Score, Timer, UI backdrop\r\n        if self.state == \"Runner\" or self.state == \"Combat\":\r\n            score = self.header.render(\"Score: \" + str(int(self.score)), False, (255, 255, 0))\r\n            pygame.draw.rect(self.win, (0, 0, 0), (0, 0, self.win.get_width(), 50))\r\n            self.win.blit(score, (self.win.get_width() - score.get_width() - 15, 5))\r\n            timer = self.header.render(str(int(self.level_timer)), False, (255, 255, 0))\r\n            self.win.blit(timer, (self.win.get_width() // 2 - timer.get_width() // 2, 5))\r\n        # State specific drawing\r\n        if self.state == \"Title\" or self.state == \"Resume\":\r\n            self.draw_title_screen(self.start_hover, self.quit_hover)\r\n        elif self.state == \"Runner\":\r\n            self.draw_level()\r\n        elif self.state == \"Combat\":\r\n            if self.player.selection is not None:\r\n                self.draw_combat_screen(self.combat_encounter, self.player.selection)\r\n                if self.attack_delay > 0 and self.cur_effect_img:\r\n                    self.win.blit(self.cur_effect_img, (self.effect_origin, 325))\r\n        if self.debug:\r\n            fps = self.header.render(\"FPS: \" + str(int(self.clock.get_fps())), False, (255, 255, 0))\r\n            self.win.blit(fps, (50, 650))\r\n        pygame.display.flip()\r\n\r\n    def draw_level(self):\r\n        self.player.draw()\r\n        if self.party[\"Wizard\"].runner_moves[\"Shield\"][0] > 0:\r\n            temp = self.normal.render(str(round(self.party[\"Wizard\"].runner_moves[\"Shield\"][0], 2)), False, (255, 255, 0))\r\n            self.win.blit(temp, (self.player.x - temp.get_width() // 2, self.player.y - temp.get_height() - 20))\r\n            self.win.blit(self.party[\"Wizard\"].shield_surf,\r\n                          (int(self.player.x - self.player.radius), int(self.player.y - self.player.radius)))\r\n        if self.party[\"Archer\"].arrow:\r\n            self.party[\"Archer\"].arrow.draw()\r\n        # self.true_scroll[1] += (self.player.y-self.true_scroll[1]-106)/20\r\n        # self.true_scroll[0] += 0\r\n        self.true_scroll[1] += 0\r\n        scroll = self.true_scroll.copy()\r\n        scroll[0] = int(scroll[0])\r\n        scroll[1] = int(scroll[1])\r\n\r\n        # Tile Generation and Enemy Spawning\r\n        self.tile_rects = []\r\n        for y in range(7):\r\n            for x in range(8):\r\n                target_x = x - 1 + int(round(scroll[0]/(self.CHUNK_SIZE*16)))\r\n                target_y = y - 1 + int(round(scroll[1]/(self.CHUNK_SIZE*16)))\r\n                target_chunk = str(target_x) + ';' + str(target_y)\r\n                if target_chunk not in self.game_map:\r\n                    self.game_map[target_chunk] = self.generate_chunk(target_x,target_y)\r\n                    for tile in self.game_map[target_chunk]:\r\n                        if tile[1] == 1 and self.object_spawn_timer <= 0 and self.distance < self.level_dist:\r\n                            enemy_or_hazard = random.randint(1, 100)\r\n                            if enemy_or_hazard > 30:\r\n                                # Spawn enemies\r\n                                next_enemy = self.available_enemies[random.randint(0, len(self.available_enemies) - 1)]((tile[0][0] * 16 - scroll[0] + 20, tile[0][1] * 16 - scroll[1]), \"Runner\", self.player.speed)\r\n                                self.onscreen_enemies.append(next_enemy)\r\n                            else:\r\n                                # Spawn an obstacle hazard\r\n                                next_hazard = self.available_hazards[random.randint(0, len(self.available_hazards) - 1)]((tile[0][0] * 16 - scroll[0] + 20, tile[0][1] * 16 - scroll[1]), self.player.speed)\r\n                                next_hazard.y -= next_hazard.height\r\n                                self.onscreen_hazards.append(next_hazard)\r\n                            self.object_spawn_timer = random.uniform(self.spawn_range[0], self.spawn_range[1])\r\n                        elif tile[1] == 1 and self.object_spawn_timer <= 0 and self.distance >= self.level_dist:\r\n                            self.onscreen_enemies.append(self.level_boss((tile[0][0] * 16 - scroll[0] + 50, tile[0][1] * 16 - scroll[1] - 50), \"Runner\", self.player.speed))\r\n                            self.object_spawn_timer = 800\r\n                    self.score += 1\r\n                    self.distance += 1\r\n                for tile in self.game_map[target_chunk]:\r\n                    self.win.blit(self.tile_index[tile[1]], (tile[0][0] * 16 - scroll[0], tile[0][1] * 16 - scroll[1]))\r\n                    if tile[1] in [1]:\r\n                        self.tile_rects.append(pygame.Rect(tile[0][0] * 16 - scroll[0], tile[0][1] * 16 - scroll[1], 16, 16))\r\n        for e in self.onscreen_enemies:\r\n            e.draw(self.win)\r\n        for h in self.onscreen_hazards:\r\n            h.draw(self.win)\r\n        # Cur Player / Player Portrait UI\r\n        n = 0\r\n        for character in self.party:\r\n            n += 1\r\n            x = self.screen_dim[0] * 0.06 + ((n - 1) * self.player.radius * 2.5)\r\n            if self.party[character] == self.player:\r\n                pygame.draw.rect(self.win, (255, 255, 255),\r\n                                 (x - 12.5, 12, self.player.radius + 5, self.player.radius + 5))\r\n            self.party[character].draw_portrait(x)\r\n        # Ability / Cooldown UI\r\n        n = 0\r\n        for ability in self.player.runner_moves:\r\n            n += 1\r\n            size = 40\r\n            rect = pygame.Rect(self.screen_dim[0] * 0.4 - (n * (size + 5)), 5, size, size)\r\n            pygame.draw.rect(self.win, (255, 255, 255), rect, 1)\r\n            if self.player.runner_moves[ability][1] > 0:\r\n                y_calc = (1 - (self.player.runner_moves[ability][1] / self.player.runner_moves[ability][2])) / 2.5 * 100\r\n                pygame.draw.line(self.win, (179, 0, 119), (rect.left, rect.top + int(y_calc)), (rect.right, rect.top + int(y_calc)))\r\n\r\n    def draw_combat_screen(self, enemy_list, selection):\r\n        # Color Palette\r\n        menu_space_color = (176, 166, 156)\r\n        text_color = (255, 73, 48)\r\n        cooldown_color = (184, 201, 207)\r\n        offset = self.player.selection - 1\r\n        self.player.draw()\r\n        # Buff Notifications\r\n        if \"Fortify\" in self.player.buffs and \"Cover\" in self.player.buffs:\r\n            temp = self.normal.render(\"Defense and Dodge Up!\", False, (11, 29, 227))\r\n            self.win.blit(temp, (self.player.x - temp.get_width() // 2, self.player.y - 60))\r\n        elif \"Fortify\" in self.player.buffs:\r\n            temp = self.normal.render(\"Defense Up!\", False, (11, 29, 227))\r\n            self.win.blit(temp, (self.player.x - temp.get_width() // 2, self.player.y - 60))\r\n        elif \"Cover\" in self.player.buffs:\r\n            temp = self.normal.render(\"Dodge Up!\", False, (11, 29, 227))\r\n            self.win.blit(temp, (self.player.x - temp.get_width() // 2, self.player.y - 60))\r\n        if self.current_opponent:\r\n            self.current_opponent.draw(self.win)\r\n            # Debuffs Notifications\r\n            if \"Stun\" in self.current_opponent.debuffs and \"Burn\" in self.current_opponent.debuffs:\r\n                self.win.blit(self.bolt_img_icon, (self.current_opponent.x - 20, self.current_opponent.y - 150))\r\n                self.win.blit(self.blaze_img_icon, (self.current_opponent.x + 20, self.current_opponent.y - 150))\r\n            elif \"Stun\" in self.current_opponent.debuffs:\r\n                self.win.blit(self.bolt_img_icon, (self.current_opponent.x - 18, self.current_opponent.y - 150))\r\n            elif \"Burn\" in self.current_opponent.debuffs:\r\n                self.win.blit(self.blaze_img_icon, (self.current_opponent.x - 18, self.current_opponent.y - 150))\r\n            if \"Pierce\" in self.current_opponent.debuffs:\r\n                temp = self.normal.render(\"Defense Down!\", False, (186, 24, 70))\r\n                self.win.blit(temp, (self.current_opponent.x - temp.get_width() // 2, self.current_opponent.y - 60))\r\n        if len(self.combat_encounter) > 1:\r\n            # Show Upcoming Enemy\r\n            temp = self.normal.render(\"Next Enemy:\", False, text_color)\r\n            pygame.draw.rect(self.win, (20, 20, 20), (645, 140, temp.get_width() + 15, temp.get_height() + 60))\r\n            pygame.draw.rect(self.win, (230, 60, 0), (645, 140, temp.get_width() + 15, temp.get_height() + 60), 5)\r\n            self.win.blit(temp, (650, 150))\r\n            self.combat_encounter[1].draw_portrait(self.win)\r\n        # Menu Options\r\n        for i in range(len(self.combat_menu[\"Main\"])):\r\n            temp = self.header.render(self.combat_menu[\"Main\"][i + 1], False, text_color)\r\n            self.win.blit(temp, (100, (self.screen_dim[1] * (0.6 + 0.05 * i))))\r\n        # Selection Arrow\r\n        if selection != 0:\r\n            if self.cur_menu == \"Abilities\":\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((50, 525), (50, 555),\r\n                                                          (95, 540)))\r\n            elif self.cur_menu == \"Swapping\":\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((50, 565), (50, 595),\r\n                                                          (95, 580)))\r\n            else:\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((50, 485 + offset * 40), (50, 515 + (offset * 40)),\r\n                                                          (95, 500 + offset * 40)))\r\n        # Player Health\r\n        temp = self.header.render(str(self.player.health), False, text_color)\r\n        self.win.blit(temp, (self.player.x - temp.get_width() // 2, self.player.y - 100))\r\n        # Opponent Health\r\n        temp = self.header.render(str(self.current_opponent.health), False, text_color)\r\n        self.win.blit(temp, (self.current_opponent.x - temp.get_width() // 2, self.current_opponent.y - 100))\r\n        # Turn Info\r\n        temp = self.header.render(self.turn + \" Turn!\", False, text_color, menu_space_color)\r\n        self.win.blit(temp, (50, 725))\r\n        # Ability Submenu\r\n        if self.cur_menu == \"Abilities\":\r\n            for i in range(len(self.player.abilities)):\r\n                # Ability name\r\n                if self.player.ability_cooldowns[i] == 0:\r\n                    temp = self.header.render(self.player.abilities[i], False, text_color)\r\n                    self.win.blit(temp, (400, (self.screen_dim[1] * (0.6 + 0.05 * i))))\r\n                else:\r\n                    temp = self.header.render(self.player.abilities[i], False, cooldown_color)\r\n                    self.win.blit(temp, (400, (self.screen_dim[1] * (0.6 + 0.05 * i))))\r\n                    temp = self.header.render(str(self.player.ability_cooldowns[i]), False, text_color)\r\n                    self.win.blit(temp, (625, (self.screen_dim[1] * (0.6 + 0.05 * i))))\r\n\r\n            # Selection Arrow\r\n            if selection != 0:\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((350, 485 + offset * 40), (350, 515 + offset * 40),\r\n                                                          (395, 500 + offset * 40)))\r\n        elif self.cur_menu == \"Swapping\":\r\n            # Menu Options\r\n            align = 0\r\n            for i in self.combat_menu[\"Swapping\"]:\r\n                if self.combat_menu[\"Swapping\"][i] != self.player.__class__.__name__:\r\n                    temp = self.header.render(self.combat_menu[\"Swapping\"][i], False, text_color)\r\n                    align = 0\r\n                    if self.player.__class__ == player.Warrior:\r\n                        align = 1\r\n                    elif self.player.__class__ == player.Archer and i == 3:\r\n                        align = 1\r\n                    self.win.blit(temp, (400, self.screen_dim[1] * (0.6 + 0.05 * (i - 1 - align))))\r\n            # Selection Arrow\r\n            if selection != 0:\r\n                if self.player.__class__ == player.Archer and selection == 1:\r\n                    align = 0\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((350, 485 + (offset - align) * 40), (350, 515 + (offset - align) * 40),\r\n                                                          (395, 500 + (offset - align) * 40)))\r\n\r\n    def draw_title_screen(self, start_highlight=False, quit_highlight=False):\r\n        bg_color = (150, 150, 150)\r\n        title_color = (255, 0, 51)\r\n        highlight_color = (0, 170, 200)\r\n        self.win.fill(bg_color)\r\n        self.win.blit(self.logo, (self.screen_dim[0] // 2 - self.logo.get_width() // 2, int(self.screen_dim[1] * 0.1)))\r\n        temp = self.title.render(\"Dungeon Rush\", False, title_color, bg_color)\r\n        self.win.blit(temp, (self.screen_dim[0] // 2 - temp.get_width() // 2, self.screen_dim[1] // 3 - temp.get_height() // 2))\r\n        temp = self.header.render(\"By Tyler Cobb and Chase Minor\", False, (0, 0, 0), bg_color)\r\n        self.win.blit(temp, (self.screen_dim[0] // 2 - temp.get_width() // 2, self.screen_dim[1] * 0.37))\r\n\r\n        if not start_highlight:\r\n            if self.state == \"Title\":\r\n                temp = self.header.render(\"Start Game\", False, title_color, bg_color)\r\n            elif self.state == \"Resume\":\r\n                temp = self.header.render(\"Resume Game\", False, title_color, bg_color)\r\n        else:\r\n            if self.state == \"Title\":\r\n                temp = self.header.render(\"Start Game\", False, highlight_color, bg_color)\r\n            elif self.state == \"Resume\":\r\n                temp = self.header.render(\"Resume Game\", False, highlight_color, bg_color)\r\n        self.start_rect = temp.get_rect()\r\n        self.start_rect[0] = self.screen_dim[0] // 2 - temp.get_width() // 2\r\n        self.start_rect[1] = int(self.screen_dim[1] * 0.55)\r\n        self.win.blit(temp, (self.screen_dim[0] // 2 - temp.get_width() // 2, int(self.screen_dim[1] * 0.55)))\r\n        if not quit_highlight:\r\n            temp = self.header.render(\"Quit Game\", False, title_color, bg_color)\r\n        else:\r\n            temp = self.header.render(\"Quit Game\", False, highlight_color, bg_color)\r\n        self.quit_rect = temp.get_rect()\r\n        self.quit_rect[0] = self.screen_dim[0] // 2 - temp.get_width() // 2\r\n        self.quit_rect[1] = int(self.screen_dim[1] * 0.6)\r\n        self.win.blit(temp, (self.screen_dim[0] // 2 - temp.get_width() // 2, int(self.screen_dim[1] * 0.63)))\r\n        if self.state == \"Resume\":\r\n            temp = self.title.render(\"Score: \" + str(self.score), False, title_color, bg_color)\r\n            self.win.blit(temp, (self.screen_dim[0] // 2 - temp.get_width() // 2, int(self.screen_dim[1] * 0.75)))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- level_manager.py	(revision dfd6dc3135f63963a9e4e2033a424b558012f53f)
+++ level_manager.py	(date 1618518444910)
@@ -12,6 +12,7 @@
         self.clock = pygame.time.Clock()
         self.debug = False
         self.state = state
+        warrior_sprites = pygame.image.load("Images\\")
         self.party = {"Warrior": player.Warrior((200, self.screen_dim[1] // 2 - 20), None, None, self.win), "Archer":
                       player.Archer((200, self.screen_dim[1] // 2 - 20), None, None, self.win), "Wizard":
                       player.Wizard((200, self.screen_dim[1] // 2 - 20), None, None, self.win)}
Index: player.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport math\r\n\r\n\r\nclass Player:\r\n    def __init__(self, start_pos, image, scale, surf):\r\n        self.color = None\r\n        self.x = start_pos[0]\r\n        self.y = start_pos[1]  \r\n#        self.image = pygame.image.load(image)\r\n#        self.width = self.image.get_width()\r\n#        self.height = self.image.get_height()\r\n#        self.scaled_image = pygame.transform.scale(self.image, (self.width * scale, self.height * scale))\r\n#        self.width *= scale\r\n#        self.height *= scale\r\n        self.radius = 20\r\n        self.jump_power = 0\r\n        self.grav = 90\r\n        self.speed = 450\r\n        self.can_jump = True\r\n        self.surf = surf\r\n        self.rect = pygame.draw.circle(self.surf, (0, 255, 0), (int(self.x), int(self.y)), self.radius)\r\n        self.selection = None\r\n        self.selection_made = False\r\n        self.special_effect = None\r\n        self.defense = 0\r\n        self.dodge = 0\r\n        self.base_dodge = 0\r\n        self.abilities = []\r\n        self.ability_cooldowns = [0, 0]\r\n        self.buffs = []\r\n        self.fortify = [\"False\", 0]\r\n        self.cover = [\"False\", 0]\r\n        self.sound = pygame.mixer.Sound(\"audio\\\\bouncy.wav\")\r\n        self.sound.set_volume(0.5)\r\n\r\n    def do_ability(self, opponent, party):\r\n        pass\r\n\r\n    def collision_test(self, tiles):\r\n        collisions = []\r\n        for tile in tiles:\r\n            if self.rect.colliderect(tile):\r\n                collisions.append(tile)\r\n        return collisions\r\n\r\n    def move_and_collide(self, tiles, dt):\r\n        collision_types = {\"bottom\": False, \"right\": False}\r\n#        collisions = self.collision_test(tiles)\r\n#        for tile in collisions:\r\n#            if tile.top <= self.rect.top:\r\n#                self.rect.right = tile.left\r\n#                self.x = self.rect.right - self.radius\r\n#                collision_types[\"right\"] = True\r\n        self.y += self.jump_power * 3 * dt\r\n        self.rect = pygame.draw.circle(self.surf, (0, 255, 0), (int(self.x), int(self.y)), self.radius)\r\n        collisions = self.collision_test(tiles)\r\n        for tile in collisions:\r\n            if self.jump_power > 0:\r\n                self.rect.bottom = tile.top\r\n                self.y = self.rect.bottom - self.radius\r\n                collision_types[\"bottom\"] = True\r\n#            elif self.jump_power < 0:\r\n#                self.rect.top = tile.bottom\r\n#                self.y = self.rect.top += self.rect.top\r\n#                collision_types[\"top\"] = True\r\n        return collision_types\r\n\r\n    def update(self, game_state, tiles, dt, enemy_list, hazard_list):\r\n        if game_state == \"Runner\":\r\n            self.jump_power += (self.grav * dt) ** 2 + 2\r\n            if self.jump_power > 100:\r\n                self.jump_power = 100\r\n\r\n            collisions = self.move_and_collide(tiles, dt)\r\n            if collisions[\"bottom\"]:\r\n                self.jump_power = 0.25\r\n                self.can_jump = True\r\n            if self.y >= 410:\r\n                self.can_jump = False\r\n\r\n        elif game_state == \"Combat\":\r\n            # Apply / Remove Fortify buff\r\n            if \"Fortify\" in self.buffs and self.fortify[0] == \"False\":\r\n                self.defense *= 1.5\r\n                self.fortify[0] = \"True\"\r\n                self.fortify[1] = 4\r\n            if self.fortify[1] == 0 and self.fortify[0] == \"True\":\r\n                self.defense /= 1.5\r\n                self.buffs.remove(\"Fortify\")\r\n                self.fortify[0] = \"False\"\r\n            # Apply / Remove Cover buff\r\n            if \"Cover\" in self.buffs and self.cover[0] == \"False\":\r\n                self.dodge = 0.33\r\n                self.cover[0] = \"True\"\r\n                self.cover[1] = 5\r\n            if self.cover[1] == 0 and self.cover[0] == \"True\":\r\n                self.dodge = self.base_dodge\r\n                self.buffs.remove(\"Cover\")\r\n                self.cover[0] = \"False\"\r\n\r\n    def handle_running_input(self, evt):\r\n        cur_class = self.__class__.__name__\r\n        if evt.type == pygame.KEYDOWN:\r\n            if evt.key == pygame.K_SPACE:\r\n                if self.can_jump:\r\n                    self.jump_power = -125\r\n                    self.can_jump = False\r\n            if evt.key == pygame.K_q:\r\n                if self.__class__.__name__ == \"Warrior\":\r\n                    cur_class = \"Wizard\"\r\n                elif self.__class__.__name__ == \"Archer\":\r\n                    cur_class = \"Warrior\"\r\n                else:\r\n                    cur_class = \"Archer\"\r\n            if evt.key == pygame.K_e:\r\n                if self.__class__.__name__ == \"Warrior\":\r\n                    cur_class = \"Archer\"\r\n                elif self.__class__.__name__ == \"Archer\":\r\n                    cur_class = \"Wizard\"\r\n                else:\r\n                    cur_class = \"Warrior\"\r\n        return cur_class\r\n\r\n    def handle_combat_input(self, evt, menu):\r\n        if self.selection == None:\r\n            if menu == \"Main\" or menu == \"Abilities\":\r\n                self.selection = 1\r\n            if menu == \"Swapping\":\r\n                if self.__class__.__name__ == \"Warrior\":\r\n                    self.selection = 2\r\n                if self.__class__.__name__ == \"Archer\" or self.__class__.__name__ == \"Wizard\":\r\n                    self.selection = 1\r\n            self.selection_made = False\r\n        if evt.type == pygame.KEYDOWN:\r\n            if not self.selection_made:\r\n                if evt.key == pygame.K_w:\r\n                    self.selection -= 1\r\n                    if menu == \"Main\":\r\n                        if self.selection < 1:\r\n                            self.selection = 3\r\n                    elif menu == \"Abilities\":\r\n                        if self.selection < 1:\r\n                            self.selection = len(self.abilities)\r\n                    elif menu == \"Swapping\":\r\n                        if self.__class__.__name__ == \"Warrior\":\r\n                            if self.selection < 2:\r\n                                self.selection = 3\r\n                        elif self.__class__.__name__ == \"Archer\":\r\n                            if self.selection < 1:\r\n                                self.selection = 3\r\n                            elif self.selection == 2:\r\n                                self.selection = 1\r\n                        else:\r\n                            if self.selection < 1:\r\n                                self.selection = 2\r\n                elif evt.key == pygame.K_s:\r\n                    self.selection += 1\r\n                    if menu == \"Main\":\r\n                        if self.selection > 3:\r\n                            self.selection = 1\r\n                    elif menu == \"Abilities\":\r\n                        if self.selection > len(self.abilities):\r\n                            self.selection = 1\r\n                    elif menu == \"Swapping\":\r\n                        if self.__class__.__name__ == \"Warrior\":\r\n                            if self.selection > 3:\r\n                                self.selection = 2\r\n                        elif self.__class__.__name__ == \"Archer\":\r\n                            if self.selection > 3:\r\n                                self.selection = 1\r\n                            elif self.selection == 2:\r\n                                self.selection = 3\r\n                        else:\r\n                            if self.selection > 2:\r\n                                self.selection = 1\r\n                elif evt.key == pygame.K_RETURN:\r\n                    self.selection_made = True\r\n            if evt.key == pygame.K_BACKSPACE:\r\n                if menu == \"Swapping\" or menu == \"Abilities\":\r\n                    self.selection = 0\r\n                    self.selection_made = True\r\n\r\n    def draw(self):\r\n        pygame.draw.circle(self.surf, (self.color), (int(self.x), int(self.y)), self.radius)\r\n        # Collision rect for debug\r\n#        pygame.draw.rect(self.surf, (255, 0, 0), self.rect, 1)\r\n\r\n    def draw_portrait(self, x):\r\n        pygame.draw.circle(self.surf, self.color, (int(x), 25), self.radius // 2)\r\n\r\n\r\nclass Warrior(Player):\r\n\r\n    def __init__(self, start_pos, image, scale, surf):\r\n        super().__init__(start_pos, image, scale, surf)\r\n        self.color = (0, 255, 0)\r\n        self.health = 250\r\n        self.max_health = self.health\r\n        self.attack = 60\r\n        self.defense = 35\r\n        self.luck = 0.05\r\n        self.dodge = 0.03\r\n        self.base_dodge = 0.03\r\n        self.runner_moves = {\"Strike\": [0.0, 0, 1]}\r\n        self.abilities = [\"Fortify\", \"Overwhelm\"]\r\n        self.ability_cooldowns = [0, 0, 7, 9]\r\n\r\n    def do_ability(self, opponent, party):\r\n        if self.selection == 1 and self.ability_cooldowns[0] == 0:\r\n            for character in party:\r\n                party[character].buffs.append(\"Fortify\")\r\n        elif self.selection == 2:\r\n            return Overwhelm()\r\n\r\n    def update(self, game_state, tiles, dt, enemy_list, hazard_list):\r\n        super().update(game_state, tiles, dt, enemy_list, hazard_list)\r\n        if self.runner_moves[\"Strike\"][0] > 0:\r\n            self.strike(enemy_list, hazard_list)\r\n\r\n    def handle_running_input(self, evt):\r\n        cur_class = super().handle_running_input(evt)\r\n        if evt.type == pygame.MOUSEBUTTONDOWN:\r\n            if evt.button == 1 and self.can_jump:\r\n                if self.runner_moves[\"Strike\"][1] <= 0 and self.runner_moves[\"Strike\"][0] <= 0:\r\n                    self.runner_moves[\"Strike\"][0] = 0.5\r\n        return cur_class\r\n\r\n    def strike(self, enemies, hazards):\r\n        collision_rect = pygame.Rect(self.x + self.radius, self.y - self.radius - 10, 50, 70)\r\n        for e in enemies:\r\n            if collision_rect.colliderect(e.rect):\r\n                e.weapon_collision = True\r\n        for h in hazards:\r\n            if collision_rect.colliderect(h.rect):\r\n                h.weapon_collision = True\r\n\r\n    def draw(self):\r\n        super().draw()\r\n        if self.runner_moves[\"Strike\"][0] > 0:\r\n            pygame.draw.rect(self.surf, (255, 0, 0), (self.x + self.radius, self.y - self.radius - 10, 60, 70), 1)\r\n\r\n\r\nclass Overwhelm:\r\n    def __init__(self):\r\n        self.attack = 100\r\n        self.luck = 0.15\r\n        self.special_effect = None\r\n        self.effect_chance = None\r\n        sword_img = pygame.image.load(\"images\\\\sword.png\")\r\n        self.image = pygame.transform.scale(sword_img, (100, 100))\r\n\r\n\r\nclass Archer(Player):\r\n\r\n    def __init__(self, start_pos, image, scale, surf):\r\n        super().__init__(start_pos, image, scale, surf)\r\n        self.color = (255, 255, 0)\r\n        self.health = 180\r\n        self.max_health = self.health\r\n        self.attack = 45\r\n        self.defense = 20\r\n        self.luck = 0.08\r\n        self.dodge = 0.06\r\n        self.base_dodge = 0.06\r\n        self.arrow = None\r\n        self.runner_moves = {\"Snipe\": [0, 0, 2.5], \"Dash\": [0, 0, 2]}\r\n        self.abilities = [\"Rapidfire\", \"Take Cover\"]\r\n        self.ability_cooldowns = [0, 0, 6, 7]\r\n\r\n    def handle_running_input(self, evt):\r\n        cur_class = super().handle_running_input(evt)\r\n        if evt.type == pygame.MOUSEBUTTONDOWN:\r\n            if evt.button == 1:\r\n                if self.runner_moves[\"Snipe\"][1] <= 0:\r\n                    self.snipe(evt.pos)\r\n            elif evt.button == 3:\r\n                if self.runner_moves[\"Dash\"][1] <= 0:\r\n                    self.runner_moves[\"Dash\"][0] = 0.2\r\n        return cur_class\r\n\r\n    def snipe(self, mouse_pos):\r\n        adjacent = mouse_pos[0] - self.x\r\n        opposite = -1 * (mouse_pos[1] - self.y)  # Account for inverted y-axis\r\n        angle = math.atan2(opposite, adjacent)\r\n        start_x = self.x + self.radius\r\n        self.arrow = Arrow(start_x, self.y, self.surf)\r\n        self.arrow.horizontal_speed = self.arrow.speed * math.cos(angle)\r\n        self.arrow.vertical_speed = -self.arrow.speed * math.sin(angle)\r\n        self.runner_moves[\"Snipe\"][1] = self.runner_moves[\"Snipe\"][2]\r\n\r\n    def do_ability(self, opponent, party):\r\n        if self.selection == 1:\r\n            return Rapidfire()\r\n        if self.selection == 2 and self.ability_cooldowns[1] == 0:\r\n            for character in party:\r\n                party[character].buffs.append(\"Cover\")\r\n\r\n\r\nclass Rapidfire:\r\n    def __init__(self):\r\n        self.attack = 80\r\n        self.luck = 0.4\r\n        self.special_effect = \"Pierce\"\r\n        self.effect_chance = 0.8\r\n        arrow_img = pygame.image.load(\"images\\\\unnamed.png\")\r\n        self.image = pygame.transform.scale(arrow_img, (arrow_img.get_width() // 4, arrow_img.get_height() // 4))\r\n\r\n\r\nclass Arrow:\r\n\r\n    def __init__(self, start_x, start_y, surf):\r\n        self.x = start_x\r\n        self.y = start_y\r\n        arrow_img = pygame.image.load(\"images\\\\unnamed.png\")\r\n        self.image = pygame.transform.scale(arrow_img, (arrow_img.get_width() // 10, arrow_img.get_height() // 10))\r\n        self.color = (153, 85, 49)\r\n        self.speed = 700\r\n        self.horizontal_speed = 0\r\n        self.vertical_speed = 0\r\n        self.surf = surf\r\n        self.width = self.image.get_width()\r\n        self.height = self.image.get_height()\r\n        self.width_edge = surf.get_width()\r\n        self.height_edge = surf.get_height()\r\n\r\n    def update(self, dt, enemies):\r\n        # Movement\r\n        self.x += self.horizontal_speed * dt\r\n        self.y += self.vertical_speed * dt\r\n\r\n        # Collision with enemies\r\n        collision_rect = pygame.Rect(int(self.x), int(self.y), self.width, self.height)\r\n        for e in enemies:\r\n            if collision_rect.colliderect(e.rect):\r\n                e.weapon_collision = True\r\n                hit = True\r\n                return hit\r\n\r\n        # Boundary check\r\n        if self.y + self.height > self.height_edge:\r\n            oob = True  # Out of bounds\r\n        elif self.y  < 0:\r\n            oob = True\r\n        elif self.x < 0:\r\n            oob = True\r\n        elif self.x + self.width > self.width_edge:\r\n            oob = True\r\n        else:\r\n            oob = False\r\n        return oob\r\n\r\n    def draw(self):\r\n        self.surf.blit(self.image, (int(self.x), int(self.y)))\r\n\r\n\r\nclass Wizard(Player):\r\n\r\n    def __init__(self, start_pos, image, scale, surf):\r\n        super().__init__(start_pos, image, scale, surf)\r\n        self.color = (0, 0, 255)\r\n        self.health = 120\r\n        self.max_health = self.health\r\n        self.attack = 20\r\n        self.defense = 10\r\n        self.luck = 0.1\r\n        self.dodge = 0.1\r\n        self.base_dodge = 0.1\r\n        self.runner_moves = {\"Shield\": [0, 0, 10]}\r\n        self.shield_surf = pygame.Surface((self.radius * 2, self.radius * 2))\r\n        self.shield_surf.set_colorkey((0, 0, 0))\r\n        self.shield_surf.set_alpha(150)\r\n        pygame.draw.circle(self.shield_surf, (66, 139, 255), (self.radius, self.radius), self.radius)\r\n        self.abilities = [\"Thunderbolt\", \"Blaze\"]\r\n        self.ability_cooldowns = [0, 0, 5, 7]   # First two numbers are current cooldown, second two are corresponding\r\n        # starting cooldowns\r\n\r\n    def handle_running_input(self, evt):\r\n        cur_class = super().handle_running_input(evt)\r\n        if evt.type == pygame.MOUSEBUTTONDOWN:\r\n            if evt.button == 1:\r\n                if self.runner_moves[\"Shield\"][1] <= 0 and self.runner_moves[\"Shield\"][0] <= 0:\r\n                    self.runner_moves[\"Shield\"][0] = 5\r\n        return cur_class\r\n\r\n    def do_ability(self, opponent, party):\r\n        if self.selection == 1:\r\n            return Thunderbolt()\r\n        if self.selection == 2:\r\n            return Blaze()\r\n\r\n\r\nclass Thunderbolt:\r\n    def __init__(self):\r\n        self.attack = 60\r\n        self.luck = 0.15\r\n        self.special_effect = \"Stun\"\r\n        self.effect_chance = 0.8\r\n        bolt_img = pygame.image.load(\"images\\\\lightning.png\")\r\n        self.image = pygame.transform.scale(bolt_img, (100, 100))\r\n\r\n\r\nclass Blaze:\r\n    def __init__(self):\r\n        self.attack = 80\r\n        self.luck = 0.1\r\n        self.special_effect = \"Burn\"\r\n        self.effect_chance = 0.6\r\n        blaze_img = pygame.image.load(\"images\\\\blaze.png\")\r\n        self.image = pygame.transform.scale(blaze_img, (100, 100))\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- player.py	(revision dfd6dc3135f63963a9e4e2033a424b558012f53f)
+++ player.py	(date 1618518382269)
@@ -3,7 +3,7 @@
 
 
 class Player:
-    def __init__(self, start_pos, image, scale, surf):
+    def __init__(self, start_pos, sprite_sheet, surf):
         self.color = None
         self.x = start_pos[0]
         self.y = start_pos[1]  
@@ -192,8 +192,8 @@
 
 class Warrior(Player):
 
-    def __init__(self, start_pos, image, scale, surf):
-        super().__init__(start_pos, image, scale, surf)
+    def __init__(self, start_pos, image, surf):
+        super().__init__(start_pos, image, surf)
         self.color = (0, 255, 0)
         self.health = 250
         self.max_health = self.health
@@ -253,8 +253,8 @@
 
 class Archer(Player):
 
-    def __init__(self, start_pos, image, scale, surf):
-        super().__init__(start_pos, image, scale, surf)
+    def __init__(self, start_pos, image, surf):
+        super().__init__(start_pos, image, surf)
         self.color = (255, 255, 0)
         self.health = 180
         self.max_health = self.health
@@ -356,8 +356,8 @@
 
 class Wizard(Player):
 
-    def __init__(self, start_pos, image, scale, surf):
-        super().__init__(start_pos, image, scale, surf)
+    def __init__(self, start_pos, image, surf):
+        super().__init__(start_pos, image, surf)
         self.color = (0, 0, 255)
         self.health = 120
         self.max_health = self.health
