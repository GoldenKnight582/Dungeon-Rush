Index: game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport level_manager\r\n\r\npygame.init()\r\nwin_dim = (800, 800)\r\nwin = pygame.display.set_mode(win_dim)\r\ndone = False\r\nLM = level_manager.LevelManager(win, \"Runner\")\r\nwhile not done:\r\n    LM.update()\r\n    done = LM.handle_input()\r\n    LM.draw()\r\n\r\npygame.quit()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- game.py	(revision b50b457c79cf1cfdc25ce090db0102e72e065f41)
+++ game.py	(date 1616701118153)
@@ -9,6 +9,7 @@
 while not done:
     LM.update()
     done = LM.handle_input()
+    win.fill((0, 0, 0))
     LM.draw()
 
-pygame.quit()
\ No newline at end of file
+pygame.quit()
Index: enemy.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\n\r\n\r\nclass Enemy:\r\n\r\n    def __init__(self, start_pos, state):\r\n        self.x = start_pos[0]\r\n        self.y = start_pos[1]\r\n#        self.image = pygame.image.load(image)\r\n#        self.width = self.image.get_width()\r\n#        self.height = self.image.get_height()\r\n#        self.scaled_image = pygame.transform.scale(self.image, (self.width * scale, self.height * scale))\r\n#        self.width *= scale\r\n#        self.height *= scale\r\n        self.game_state = state\r\n        self.speed = None\r\n        self.radius = None\r\n        self.enemy_point = 100\r\n\r\n    def update(self, dt, player_x, player_y):\r\n        collision = False\r\n        self.x -= self.speed * dt\r\n        # Collision Check\r\n        if ((self.x - player_x) ** 2 + (self.y - player_y) ** 2) ** 0.5 <= self.radius + 20:\r\n            collision = True\r\n        return collision\r\n\r\n\r\nclass BasicEnemyTypeTest(Enemy):\r\n\r\n    def __init__(self, start_pos, state):\r\n        super().__init__(start_pos, state)\r\n        self.health = 100\r\n        self.radius = 20\r\n        self.attack = 30\r\n        self.defense = 10\r\n        self.luck = 0.02\r\n        self.speed = 350\r\n\r\n    def draw(self, surf):\r\n        pygame.draw.circle(surf, (255, 0, 0), (int(self.x), int(self.y)), self.radius)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- enemy.py	(revision b50b457c79cf1cfdc25ce090db0102e72e065f41)
+++ enemy.py	(date 1616703741599)
@@ -13,13 +13,13 @@
 #        self.width *= scale
 #        self.height *= scale
         self.game_state = state
-        self.speed = None
         self.radius = None
+        self.speed = 232
         self.enemy_point = 100
 
     def update(self, dt, player_x, player_y):
-        collision = False
         self.x -= self.speed * dt
+        collision = False
         # Collision Check
         if ((self.x - player_x) ** 2 + (self.y - player_y) ** 2) ** 0.5 <= self.radius + 20:
             collision = True
@@ -35,7 +35,6 @@
         self.attack = 30
         self.defense = 10
         self.luck = 0.02
-        self.speed = 350
 
-    def draw(self, surf):
-        pygame.draw.circle(surf, (255, 0, 0), (int(self.x), int(self.y)), self.radius)
\ No newline at end of file
+    def draw(self, surf, scroll_x):
+        pygame.draw.circle(surf, (255, 0, 0), (int(self.x), int(self.y)), self.radius)
Index: level_manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport random\r\nimport player\r\nimport enemy\r\nimport noise\r\n\r\n\r\nclass LevelManager():\r\n    def __init__(self, win, state):\r\n        self.win = win\r\n        self.screen_dim = (win.get_width(), win.get_height())\r\n        self.clock = pygame.time.Clock()\r\n        self.state = state\r\n        self.party = {\"Warrior\": player.Warrior((200, self.screen_dim[1] // 2 - 20), None, None, self.win), \"Archer\":\r\n                      player.Archer((200, self.screen_dim[1] // 2 - 20), None, None, self.win), \"Wizard\":\r\n                      player.Wizard((200, self.screen_dim[1] // 2 - 20), None, None, self.win)}\r\n        self.player = self.party[\"Warrior\"]\r\n        self.combat_encounter = []\r\n        self.current_opponent = None\r\n        self.cur_menu = \"Main\"\r\n        self.font = pygame.font.Font(\"Fonts\\\\Orbitron-Regular.ttf\", 30)\r\n        self.combat_menu = {\"Main\": {1: \"Attack\", 2: \"Special\", 3: \"Swap\"}, \"Swapping\":\r\n                            {1: \"Warrior\", 2: \"Archer\", 3: \"Wizard\"}, \"Abilities\":\r\n                            self.player.abilities}\r\n        self.attack_delay = 0\r\n        self.turn = \"Player\"\r\n        self.turn_count = 1\r\n\r\n        # World Generation and Scrolling data\r\n        self.true_scroll = [0, 0]\r\n        self.CHUNK_SIZE = 16\r\n        self.game_map = {}\r\n        self.grass_img = pygame.image.load('images\\\\cobblestone.jpg')\r\n        self.dirt_img = pygame.image.load('images\\\\rock.png')\r\n        self.plant_img = pygame.image.load('images\\\\plant.png').convert()\r\n        self.plant_img.set_colorkey((255,255,255))\r\n        self.tile_index = {1:self.grass_img, 2:self.dirt_img, 3:self.plant_img}\r\n        self.cave_img = pygame.image.load('images\\\\cave.png')\r\n        self.tile_rects = []\r\n        # credits for cave img = http://pixeljoint.com/forum/forum_posts.asp?TID=15971&PD=0\r\n        self.cave_scroll_x = 0\r\n        self.score = -56\r\n        self.distance = -56\r\n\r\n        # Music by AlexisOrtizSofield from Pixabay\r\n        pygame.mixer.music.load(\"audio\\\\music.mp3\")\r\n        pygame.mixer.music.set_volume(1)\r\n        pygame.mixer.music.play(-1)\r\n\r\n        # Obstacle Spawn Data\r\n        self.onscreen_enemies = []\r\n        self.enemy_spawn_timer = random.randint(3, 5)\r\n\r\n    def generate_chunk(self, x, y):\r\n        cal = self.screen_dim[1] / 2 / self.CHUNK_SIZE\r\n        chunk_data = []\r\n        for y_pos in range(self.CHUNK_SIZE):\r\n            for x_pos in range(self.CHUNK_SIZE):\r\n                target_x = x * self.CHUNK_SIZE + x_pos\r\n                target_y = y * self.CHUNK_SIZE + y_pos\r\n                tile_type = 0 # nothing\r\n                height = int(noise.pnoise1(target_x * 0.1, repeat=9999999) * 5)\r\n                if target_y > cal - height * 3:\r\n                    tile_type = 2 # dirt\r\n                elif target_y == cal - height * 3:\r\n                    tile_type = 1 # grass\r\n                if tile_type != 0:\r\n                    chunk_data.append([[target_x,target_y],tile_type])\r\n        return chunk_data\r\n\r\n    def update(self):\r\n        \"\"\"\r\n        General updates called every frame\r\n        \"\"\"\r\n        delta_time = self.clock.tick() / 1000\r\n        for character in self.party:\r\n            self.party[character].update(self.state, delta_time, self.turn_count, self.party)\r\n\r\n        self.cave_scroll_x -= 0.2\r\n\r\n        for e in self.onscreen_enemies:\r\n            if e.x <= self.distance:\r\n                self.score += e.enemy_point\r\n                e.enemy_point = 0\r\n\r\n        if self.state == \"Runner\":\r\n            # Sync the current jump power for the whole party\r\n            self.sync_party()\r\n            # Spawn enemies\r\n            self.enemy_spawn_timer -= delta_time\r\n            if self.enemy_spawn_timer <= 0:\r\n                self.onscreen_enemies.append(enemy.BasicEnemyTypeTest((self.screen_dim[0] - 20, self.screen_dim[1] // 2 - 20), \"Runner\"))\r\n                self.enemy_spawn_timer = random.uniform(2, 3.5)\r\n            # Enemy Collision and Combat Generation\r\n            for e in self.onscreen_enemies:\r\n                hit = e.update(delta_time, self.player.x, self.player.y)\r\n                if hit:\r\n                    self.combat_encounter = [e]\r\n                    for i in range(random.randint(2, 3)):\r\n                        new_enemy = enemy.BasicEnemyTypeTest((self.screen_dim[0] // 2, self.screen_dim[1] // 2 - 20), self.state)\r\n                        self.combat_encounter.append(new_enemy)\r\n                    self.onscreen_enemies.remove(e)\r\n                    for e in self.combat_encounter:\r\n                        e.x = 600\r\n                    for character in self.party:\r\n                        self.party[character].y = 380\r\n                    self.state = \"Combat\"\r\n            # Despawn offscreen enemies\r\n            for e in self.onscreen_enemies:\r\n                if e.x - e.radius <= 0:\r\n                    self.onscreen_enemies.remove(e)\r\n\r\n        if self.state == \"Combat\":\r\n            self.attack_delay -= delta_time\r\n            self.current_opponent = self.combat_encounter[0]\r\n            if self.turn == \"Player\":\r\n                if self.cur_menu == \"Main\":\r\n                    if self.player.selection_made:\r\n                        if self.player.selection == 1:\r\n                            self.attack(self.player, self.current_opponent)\r\n                            self.change_turn()\r\n                        elif self.player.selection == 2:\r\n                            self.menu_change(\"Abilities\")\r\n                        elif self.player.selection == 3:\r\n                            self.menu_change(\"Swapping\")\r\n                elif self.cur_menu == \"Abilities\":\r\n                    if self.player.selection_made:\r\n                        if self.player.selection == 0:\r\n                            self.menu_change(\"Main\")\r\n                        else:\r\n                            self.player.do_ability(self.current_opponent, self.party)\r\n                            self.change_turn()\r\n                            self.menu_change(\"Main\")\r\n                elif self.cur_menu == \"Swapping\":\r\n                    if self.player.selection_made:\r\n                        if self.player.selection == 0:\r\n                            self.menu_change(\"Main\")\r\n                        elif self.player.selection == 1:\r\n                            self.player = self.party[\"Warrior\"]\r\n                            self.menu_change(\"Main\")\r\n                            self.change_turn()\r\n                        elif self.player.selection == 2:\r\n                            self.player = self.party[\"Archer\"]\r\n                            self.menu_change(\"Main\")\r\n                            self.change_turn()\r\n                        elif self.player.selection == 3:\r\n                            self.player = self.party[\"Wizard\"]\r\n                            self.player.selection_made = False\r\n                            self.player.selection = None\r\n                            self.cur_menu = \"Main\"\r\n                            self.change_turn()\r\n            if self.turn == \"Enemy\":\r\n                if self.current_opponent:\r\n                    if self.attack_delay <= 0:\r\n                        self.attack(self.current_opponent, self.player)\r\n                        self.change_turn()\r\n                        self.player.selection_made = False\r\n            if self.current_opponent.health <= 0:\r\n                self.combat_encounter.remove(self.current_opponent)\r\n            if not self.combat_encounter:\r\n                self.state = \"Runner\"\r\n\r\n    def attack(self, attackee, attacked):\r\n        damage = attackee.attack - random.randint(attacked.defense - 15, attacked.defense)\r\n        if damage < 0:\r\n            damage = 0\r\n        crit_chance = attackee.luck * 100\r\n        if random.randint(crit_chance, 100) == crit_chance:\r\n            damage *= 2\r\n        attacked.health -= damage\r\n\r\n    def menu_change(self, next_menu):\r\n        self.player.selection_made = False\r\n        if self.cur_menu == \"Swapping\":\r\n            self.player.selection = 3\r\n        elif self.cur_menu == \"Abilities\":\r\n            self.player.selection = 2\r\n        else:\r\n            self.player.selection = None\r\n        self.cur_menu = next_menu\r\n\r\n    def sync_party(self):\r\n        self.party[\"Warrior\"].jump_power = self.player.jump_power\r\n        self.party[\"Archer\"].jump_power = self.player.jump_power\r\n        self.party[\"Wizard\"].jump_power = self.player.jump_power\r\n\r\n    def change_turn(self):\r\n        if self.turn == \"Player\":\r\n            self.turn = \"Enemy\"\r\n            self.attack_delay = 0.33\r\n        else:\r\n            self.turn = \"Player\"\r\n        self.turn_count += 1\r\n\r\n    def handle_input(self):\r\n        \"\"\"\r\n        Handles input between the player and UI / game objects\r\n        :return: True if the player is exiting the game\r\n        \"\"\"\r\n        event = pygame.event.poll()\r\n\r\n        if event.type == pygame.QUIT:\r\n            return True\r\n        if event.type == pygame.KEYDOWN:\r\n            if event.key == pygame.K_ESCAPE:\r\n                return True\r\n\r\n        if self.state == \"Runner\":\r\n            self.player = self.party[self.player.handle_running_input(event)]\r\n        elif self.state == \"Combat\":\r\n            self.player.handle_combat_input(event, self.cur_menu)\r\n\r\n    def draw(self):\r\n        score = self.font.render(\"Score:\" + str(int(self.score)), False, (255, 255, 0))\r\n        self.win.blit(self.cave_img,(self.cave_scroll_x, 0))\r\n        self.win.blit(self.cave_img, (self.cave_scroll_x + self.cave_img.get_width(), 0))\r\n        if self.cave_scroll_x <= -self.cave_img.get_width():\r\n            self.cave_scroll_x = 0\r\n        if self.state == \"Runner\":\r\n            self.draw_level()\r\n            pygame.draw.rect(self.win, (0,0,0), (0,0,self.win.get_width(), 50))\r\n            self.win.blit(score, (self.win.get_width() - 200, 5))\r\n        elif self.state == \"Combat\":\r\n            if self.player.selection is not None:\r\n                self.draw_combat_screen(self.combat_encounter, self.player.selection)\r\n        pygame.display.flip()\r\n\r\n    def draw_level(self):\r\n        self.player.draw()\r\n        self.true_scroll[0] += self.player.speed\r\n        #self.true_scroll[1] += (self.player.y-self.true_scroll[1]-106)/20\r\n        #self.true_scroll[0] += 0\r\n        self.true_scroll[1] += 0\r\n        scroll = self.true_scroll.copy()\r\n        scroll[0] = int(scroll[0])\r\n        scroll[1] = int(scroll[1])\r\n\r\n        tile_rects = []\r\n        for y in range(7):\r\n            for x in range(8):\r\n                target_x = x - 1 + int(round(scroll[0]/(self.CHUNK_SIZE*16)))\r\n                target_y = y - 1 + int(round(scroll[1]/(self.CHUNK_SIZE*16)))\r\n                target_chunk = str(target_x) + ';' + str(target_y)\r\n                if target_chunk not in self.game_map:\r\n                    self.game_map[target_chunk] = self.generate_chunk(target_x,target_y)\r\n                    self.score += 1\r\n                    self.distance += 1\r\n                for tile in self.game_map[target_chunk]:\r\n                    self.win.blit(self.tile_index[tile[1]], (tile[0][0]*16-scroll[0], tile[0][1]*16 - scroll[1]))\r\n                    if tile[1] in [1, 2]:\r\n                        tile_rects.append(pygame.Rect(tile[0][0]*16, tile[0][1] * 16, 16, 16))\r\n        for e in self.onscreen_enemies:\r\n            e.draw(self.win)\r\n\r\n    def draw_combat_screen(self, enemy_list, selection):\r\n        self.player.draw()\r\n        if self.current_opponent:\r\n            self.current_opponent.draw(self.win)\r\n        # Color Palette\r\n        menu_space_color = (176, 166, 156)\r\n        outline_color = (255, 152, 48)\r\n        text_color = (255, 73, 48)\r\n        # Menu Area\r\n#        pygame.draw.rect(self.win, menu_space_color, (0, 401, self.screen_dim[0], self.screen_dim[1] - 401))\r\n#        pygame.draw.rect(self.win, outline_color, (0, 401, self.screen_dim[0], self.screen_dim[1] - 401), 5)\r\n        offset = self.player.selection - 1\r\n        # Menu Options\r\n        temp = self.font.render(\"Attack\", False, text_color)\r\n        self.win.blit(temp, (100, self.screen_dim[1] * 0.6))\r\n        temp = self.font.render(\"Abilities\", False, text_color)\r\n        self.win.blit(temp, (100, self.screen_dim[1] * 0.65))\r\n        temp = self.font.render(\"Swap\", False, text_color)\r\n        self.win.blit(temp, (100, self.screen_dim[1] * 0.7))\r\n        # Player Health\r\n        temp = self.font.render(str(self.player.health), False, text_color)\r\n        self.win.blit(temp, (self.player.x - self.player.radius * 1.5, self.player.y - 100))\r\n        # Opponent Health\r\n        temp = self.font.render(str(self.current_opponent.health), False, text_color)\r\n        if self.current_opponent.health >= 100:\r\n            self.win.blit(temp, (self.current_opponent.x - self.current_opponent.radius * 1.5, self.current_opponent.y - 100))\r\n        else:\r\n            self.win.blit(temp, (self.current_opponent.x - self.current_opponent.radius - 5, self.current_opponent.y - 100))\r\n        # Selection Arrow\r\n        if selection != 0:\r\n            if self.combat_menu[\"Main\"][selection] == \"Attack\" and self.cur_menu == \"Main\":\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((50, 485), (50, 515), (95, 500)))\r\n            if self.combat_menu[\"Main\"][selection] == \"Special\" and self.cur_menu == \"Main\" or self.cur_menu == \"Abilities\":\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((50, 525), (50, 555), (95, 540)))\r\n            if self.combat_menu[\"Main\"][selection] == \"Swap\" and self.cur_menu == \"Main\" or self.cur_menu == \"Swapping\":\r\n                pygame.draw.polygon(self.win, (0, 0, 0), ((50, 565), (50, 595), (95, 580)))\r\n        # Turn Info\r\n        temp = self.font.render(self.turn + \" Turn!\", False, text_color, menu_space_color)\r\n        self.win.blit(temp, (50, 725))\r\n        if self.cur_menu == \"Abilities\":\r\n            for i in range(len(self.player.abilities)):\r\n                temp = self.font.render(self.player.abilities[i], False, text_color, menu_space_color)\r\n                self.win.blit(temp, (400, (self.screen_dim[1] * (0.6 + 0.05 * i))))\r\n                # Selection Arrow\r\n                if selection != 0:\r\n                    pygame.draw.polygon(self.win, (0, 0, 0), ((350, 485 + offset * 40), (350, 515 + (offset * 40)),\r\n                                                              (395, 500 + offset * 40)))\r\n        if self.cur_menu == \"Swapping\":\r\n            if self.player.__class__ == player.Warrior:\r\n                # Menu Options\r\n                temp = self.font.render(\"Archer\", False, text_color, menu_space_color)\r\n                self.win.blit(temp, (400, self.screen_dim[1] * 0.6))\r\n                temp = self.font.render(\"Wizard\", False, text_color, menu_space_color)\r\n                self.win.blit(temp, (400, self.screen_dim[1] * 0.65))\r\n                # Selection Arrow\r\n                if selection != 0:\r\n                    if self.combat_menu[\"Swapping\"][selection] == \"Archer\":\r\n                        pygame.draw.polygon(self.win, (0, 0, 0), ((350, 485), (350, 515), (395, 500)))\r\n                    if self.combat_menu[\"Swapping\"][selection] == \"Wizard\":\r\n                        pygame.draw.polygon(self.win, (0, 0, 0), ((350, 525), (350, 555), (395, 540)))\r\n            if self.player.__class__ == player.Archer:\r\n                # Menu Options\r\n                temp = self.font.render(\"Warrior\", False, text_color, menu_space_color)\r\n                self.win.blit(temp, (400, self.screen_dim[1] * 0.6))\r\n                temp = self.font.render(\"Wizard\", False, text_color, menu_space_color)\r\n                self.win.blit(temp, (400, self.screen_dim[1] * 0.65))\r\n                # Selection Arrow\r\n                if selection != 0:\r\n                    if self.combat_menu[\"Swapping\"][selection] == \"Warrior\":\r\n                        pygame.draw.polygon(self.win, (0, 0, 0), ((350, 485), (350, 515), (395, 500)))\r\n                    if self.combat_menu[\"Swapping\"][selection] == \"Wizard\":\r\n                        pygame.draw.polygon(self.win, (0, 0, 0), ((350, 525), (350, 555), (395, 540)))\r\n            if self.player.__class__ == player.Wizard:\r\n                # Menu Options\r\n                temp = self.font.render(\"Warrior\", False, text_color, menu_space_color)\r\n                self.win.blit(temp, (400, self.screen_dim[1] * 0.6))\r\n                temp = self.font.render(\"Archer\", False, text_color, menu_space_color)\r\n                self.win.blit(temp, (400, self.screen_dim[1] * 0.65))\r\n                # Selection Arrow\r\n                if selection != 0:\r\n                    if self.combat_menu[\"Swapping\"][selection] == \"Warrior\":\r\n                        pygame.draw.polygon(self.win, (0, 0, 0), ((350, 485), (350, 515), (395, 500)))\r\n                    if self.combat_menu[\"Swapping\"][selection] == \"Archer\":\r\n                        pygame.draw.polygon(self.win, (0, 0, 0), ((350, 525), (350, 555), (395, 540)))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- level_manager.py	(revision b50b457c79cf1cfdc25ce090db0102e72e065f41)
+++ level_manager.py	(date 1616704313702)
@@ -32,9 +32,7 @@
         self.game_map = {}
         self.grass_img = pygame.image.load('images\\cobblestone.jpg')
         self.dirt_img = pygame.image.load('images\\rock.png')
-        self.plant_img = pygame.image.load('images\\plant.png').convert()
-        self.plant_img.set_colorkey((255,255,255))
-        self.tile_index = {1:self.grass_img, 2:self.dirt_img, 3:self.plant_img}
+        self.tile_index = {1:self.grass_img, 2:self.dirt_img}
         self.cave_img = pygame.image.load('images\\cave.png')
         self.tile_rects = []
         # credits for cave img = http://pixeljoint.com/forum/forum_posts.asp?TID=15971&PD=0
@@ -74,7 +72,7 @@
         """
         delta_time = self.clock.tick() / 1000
         for character in self.party:
-            self.party[character].update(self.state, delta_time, self.turn_count, self.party)
+            self.party[character].update(self.state, delta_time, self.turn_count, self.party)  
 
         self.cave_scroll_x -= 0.2
 
@@ -84,13 +82,9 @@
                 e.enemy_point = 0
 
         if self.state == "Runner":
+            self.enemy_spawn_timer -= delta_time
             # Sync the current jump power for the whole party
             self.sync_party()
-            # Spawn enemies
-            self.enemy_spawn_timer -= delta_time
-            if self.enemy_spawn_timer <= 0:
-                self.onscreen_enemies.append(enemy.BasicEnemyTypeTest((self.screen_dim[0] - 20, self.screen_dim[1] // 2 - 20), "Runner"))
-                self.enemy_spawn_timer = random.uniform(2, 3.5)
             # Enemy Collision and Combat Generation
             for e in self.onscreen_enemies:
                 hit = e.update(delta_time, self.player.x, self.player.y)
@@ -102,6 +96,7 @@
                     self.onscreen_enemies.remove(e)
                     for e in self.combat_encounter:
                         e.x = 600
+                        e.y = 380
                     for character in self.party:
                         self.party[character].y = 380
                     self.state = "Combat"
@@ -243,6 +238,11 @@
                 target_chunk = str(target_x) + ';' + str(target_y)
                 if target_chunk not in self.game_map:
                     self.game_map[target_chunk] = self.generate_chunk(target_x,target_y)
+                    for tile in self.game_map[target_chunk]:
+                        if tile[1] == 1 and self.enemy_spawn_timer <= 0:
+                            # Spawn enemies
+                            self.onscreen_enemies.append(enemy.BasicEnemyTypeTest((tile[0][0] * 16 - scroll[0], tile[0][1] * 16 - scroll[1] - 20), "Runner"))
+                            self.enemy_spawn_timer = random.uniform(2, 3.5)
                     self.score += 1
                     self.distance += 1
                 for tile in self.game_map[target_chunk]:
@@ -250,12 +250,12 @@
                     if tile[1] in [1, 2]:
                         tile_rects.append(pygame.Rect(tile[0][0]*16, tile[0][1] * 16, 16, 16))
         for e in self.onscreen_enemies:
-            e.draw(self.win)
+            e.draw(self.win, scroll[0])
 
     def draw_combat_screen(self, enemy_list, selection):
         self.player.draw()
         if self.current_opponent:
-            self.current_opponent.draw(self.win)
+            self.current_opponent.draw(self.win, 0)
         # Color Palette
         menu_space_color = (176, 166, 156)
         outline_color = (255, 152, 48)
